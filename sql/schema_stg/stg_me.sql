/*
STAGE THE MEDICAL ELIGIBILITY TABLE

DEPENDENCIES:
	STG.PATKEY_LIST
	RAW.ME

RESULT:
  	A TABLE WITH ONE ROW PER PATIENT MONTH COMBINATION AND FLAGS FOR VARIOUS TYPES OF
  	INSURACE ELIGIBILITY

*/


--SELECT DATABASE
USE @DATABASE@;
GO

-- PUT SOURCE ME DATA IN A TEMP TABLE
-- SELECT TOP 100 * FROM STG.PATKEY_LIST;
DROP TABLE IF EXISTS ##TMP_ME;
SELECT A.*, C.PAYER_TYPE
INTO ##TMP_ME
FROM RAW.ME A
INNER JOIN STG.PATKEY_LIST B
ON A.ME910_MHDO_MEMBERID = B.PATKEY_CHR
LEFT JOIN RAW.ME_FILEID_PAYERTYPE C
ON A.ME906_FILEID = C.ME906_FILEID;
GO

-- DDL FOR STG.ME
DROP TABLE IF EXISTS STG.ME;
CREATE TABLE STG.ME (
	PATKEY INT NOT NULL
	,YEAR SMALLINT
	,MONTH TINYINT
	,BIRTHYEAR SMALLINT
	,GENDER VARCHAR(5)
	,PATCITY VARCHAR(100)
	,PATST VARCHAR(5)
	,PATZIP VARCHAR(10)
	,COUNTY_FIPS VARCHAR(10)
	-- ,MEDICAL BIT
	,MEDICARE_FLAG BIT
	,MEDICAID_FLAG BIT
	,COMMERCIAL_FLAG BIT
	,RX_FLAG BIT
	,PHARMACY_FLAG BIT
);
GO

-- INSERT PATKEY, YEAR, MONTH INTO STG.ME
INSERT INTO STG.ME (PATKEY, YEAR, MONTH)
SELECT DISTINCT --TOP 100
    ME910_MHDO_MEMBERID AS PATKEY,
    ME004_YEAR AS YEAR,
	ME005_MONTH AS MONTH
FROM ##TMP_ME
WHERE
	ME910_MHDO_MEMBERID IS NOT NULL AND
	ME004_YEAR IS NOT NULL AND
	ME005_MONTH IS NOT NULL
ORDER BY PATKEY, YEAR, MONTH; -- NOT SURE IF ORDERING DOES ANYTHING
GO

-- CALCULATE APPROXIMATE BIRTHYEAR
-- EACH PERSON SHOULD BASICALLY HAVE TWO AGES AND THUS TWO POSSIBLE BIRTHYEAR VALUES PER YEAR.
-- WE WANT THE SMALLER OF THE TWO MOST POPULAR BIRTHYEARS WHICH SHOULD BE
-- SELECT ONLY THE MOST FREQUENTLY USED NON MISSING VALUE FOR EACH PATKEY
DROP TABLE IF EXISTS ##TMP_PATKEY_BIRTHYEAR;
SELECT PATKEY, BIRTHYEAR, N, RANKS, MIN(BIRTHYEAR) OVER(PARTITION BY PATKEY ORDER BY BIRTHYEAR) AS MIN_BIRTHYEAR
INTO ##TMP_PATKEY_BIRTHYEAR
FROM(
	SELECT PATKEY, BIRTHYEAR, N, RANKS
	FROM(
    -- RANK_TBL: A TABLE WITH RANKED BIRTHYEAR IN ORDER OF FREQUENCY
		SELECT PATKEY, BIRTHYEAR, N, RANK() OVER (PARTITION BY PATKEY ORDER BY N DESC) AS RANKS
		FROM (
		-- COUNT_TBL: A TABLE WITH A BIRTHYEAR COUNT BY PATKEY
			SELECT PATKEY, BIRTHYEAR, COUNT(*) AS N
			FROM (
			-- BIRTHYEAR_TBL: A TABLE WITH A CLEAN BIRTHYEAR CALCULATION FOR EACH ROW IN ME
				SELECT PATKEY, YEAR - AGE AS BIRTHYEAR
				FROM (
					-- T2: ##TMP_ME WITH JUST THE COLUMNS WE NEED
					SELECT
						CAST(ME910_MHDO_MEMBERID AS INT) AS PATKEY,
						CAST(ME004_YEAR AS INT) AS YEAR,
						CAST(ME901_AGE AS INT) AS AGE
					--FROM (SELECT TOP 1000 * FROM ##TMP_ME) T1 -- FOR TESTING
					FROM ##TMP_ME
				) T2
				WHERE AGE <= 110 AND AGE >= 0 AND YEAR >= 2000 AND YEAR <= 2019
			) BIRTHYEAR_TBL
			GROUP BY  PATKEY, BIRTHYEAR
		) COUNT_TBL
	) RANK_TBL
  WHERE RANKS <= 2
) TWO_HIGHEST_RANKS_TBL;

-- SELECT * FROM ##TMP_PATKEY_BIRTHYEAR
GO

-- VALIDATE MAX AND MIN BIRTHYEAR DIFFERENCES ARE MOSTLY ONES
-- EACH PERSON SHOULD HAVE MOSTLY TWO POSSIBLE BIRTHYEARS BASED ON AGE
DECLARE @NUMBER FLOAT;
WITH T1 AS(
  SELECT MAX(BIRTHYEAR) - MIN(BIRTHYEAR) AS DIF
  FROM ##TMP_PATKEY_BIRTHYEAR
  GROUP BY PATKEY
)
,T2 AS(
	SELECT
		DIF,
		COUNT(*) AS N,
		COUNT(*) * 100.0 / SUM(COUNT(*)) OVER() AS PCT
	FROM T1
	GROUP BY DIF
)
,T3 AS(
	SELECT PCT AS PCT_DIFF_OF_ONE
	FROM T2
	WHERE DIF = 1
)
SELECT @NUMBER = PCT_DIFF_OF_ONE FROM T3;
IF @NUMBER < 70 THROW 50000, 'MAX-MIN BIRTHYEAR VAIDATION FAILED', 1;
GO




-- VALIDATE THAT WE HAVE ONE BIRTHYEAR RECORD PER PATIENT
DECLARE @NUMBER FLOAT;
WITH T1 AS(
	SELECT PATKEY, COUNT(*) AS N_RECORDS
	FROM (SELECT DISTINCT PATKEY, MIN_BIRTHYEAR FROM ##TMP_PATKEY_BIRTHYEAR) T0
	GROUP BY PATKEY
)
,T2 AS(
	SELECT
		N_RECORDS,
		COUNT(*) AS N_PATKEYS,
		COUNT(*) * 100.0 / SUM(COUNT(*)) OVER() AS PCT_PATKEYS
	FROM T1
	GROUP BY N_RECORDS
)
SELECT @NUMBER = PCT_PATKEYS FROM T2 WHERE N_RECORDS = 1;
IF @NUMBER != 100 THROW 50000, 'UNIQUE BIRTHYEAR VAIDATION FAILED', 1;
GO


-- INSERT BIRTHYEAR INTO THE STG.ME TABLE
UPDATE STG.ME
SET STG.ME.BIRTHYEAR = T1.BIRTHYEAR
FROM
  STG.ME INNER JOIN
  (SELECT DISTINCT PATKEY, MIN_BIRTHYEAR AS BIRTHYEAR FROM ##TMP_PATKEY_BIRTHYEAR) T1
ON STG.ME.PATKEY = T1.PATKEY
GO

-- CALCULATE GENDER FOR EACH PERSON
DROP TABLE IF EXISTS ##TMP_PATKEY_GENDER;
-- GET MOST COMMON GENDER THAT IS M OR F
SELECT DISTINCT PATKEY,
		FIRST_VALUE(GENDER) OVER(PARTITION BY PATKEY ORDER BY N DESC) AS GENDER
INTO ##TMP_PATKEY_GENDER
FROM(
	-- COUNT GENDER BY PATKEY
	SELECT PATKEY, GENDER, COUNT(*) AS N
	FROM(
		SELECT
			CAST(ME910_MHDO_MEMBERID AS INT) AS PATKEY,
			ME013_GENDER AS GENDER
		--FROM (SELECT TOP 1000 * FROM ##TMP_ME) T1 -- FOR DEVELOPMENT
		FROM ##TMP_ME
		WHERE ME013_GENDER IN ('M','F')
	) T2
	GROUP BY PATKEY, GENDER
) T3;
-- SELECT * FROM ##TMP_PATKEY_GENDER
GO

-- VALIDATE THAT WE HAVE ONE GENDER RECORD PER PATIENT
DECLARE @NUMBER FLOAT;
WITH T1 AS(
	SELECT PATKEY, COUNT(*) AS N_RECORDS
	FROM ##TMP_PATKEY_GENDER
	GROUP BY PATKEY
)
,T2 AS(
	SELECT
		N_RECORDS,
		COUNT(*) AS N_PATKEYS,
		COUNT(*) * 100.0 / SUM(COUNT(*)) OVER() AS PCT_PATKEYS
	FROM T1
	GROUP BY N_RECORDS
)
SELECT @NUMBER = PCT_PATKEYS FROM T2 WHERE N_RECORDS = 1;
IF @NUMBER != 100 THROW 50000, 'UNIQUE GENDER VAIDATION FAILED', 1;
GO


-- ADD GENDER TO THE STG.ME TABLE
UPDATE STG.ME
SET STG.ME.GENDER = T1.GENDER
FROM
  STG.ME INNER JOIN
  (SELECT DISTINCT PATKEY, GENDER FROM ##TMP_PATKEY_GENDER) T1
ON STG.ME.PATKEY = T1.PATKEY;
GO


-- VALIDATE PERCENTAGE OF ME.GENDER POPULATED
DECLARE @NUMBER FLOAT;
WITH T1 AS(
	SELECT TOP 10
	GENDER,
	COUNT(*) AS N,
	COUNT(*) * 100.0 / SUM(COUNT(*)) OVER() AS PCT
FROM STG.ME
GROUP BY GENDER
)
,T2 AS (
	SELECT PCT AS PCT_FEMALE
	FROM T1
	WHERE GENDER = 'F'
)
SELECT @NUMBER = PCT_FEMALE FROM T2;
IF @NUMBER > 80 OR @NUMBER < 20 THROW 50000, 'GENDER PCT VAIDATION FAILED', 1;
GO


/*
SHOULD WE DROP PATIENTS WITHOUT A KNOWN GENDER?
LOG PERCENTAGE OF PATIENTS WITHOUT GENDER

--------------- LOCATION VARIABLES BY MONTH ----------------------
TAKE THE MOST FREQUENTLY OCCURING LOCATION VARIABLES WITHIN EACH MONTH
PATCITY, PATST, PATZIP, COUNTY_FIPS
*/

-- VERIFY THAT WE DO INDEED NEED TO DISAMBIGUATE LOATION INFORMATION FOR EACH PATIENT-MONTH
SELECT N AS N_UNIQUE_LOCATION_COMBINATIONS, COUNT(*) AS N_RECORDS
FROM(
	SELECT PATKEY, PATCITY, PATST, PATZIP, COUNT(*) AS N
	FROM(
		SELECT --TOP 100
			CAST(ME910_MHDO_MEMBERID AS INT) AS PATKEY
			,CAST(ME004_YEAR AS SMALLINT) AS YEAR
			,CAST(ME005_MONTH AS TINYINT) AS MONTH
			,ME015_PATCITY AS PATCITY
			,ME016_PATST AS PATST
			,ME017_PATZIP AS PATZIP
		FROM ##TMP_ME
		) T1
	GROUP BY  YEAR, MONTH, PATKEY, PATCITY, PATST, PATZIP
	) T2
GROUP BY N;
-- THIS RESULT SHOWS THAT THERE ARE MANY PATIENT-MONTH COMBINATIONS WITH MULTIPLE LOCATIONS
-- WE WILL JUST USE THE MOST COMMON FOR LACK OF A BETTER METHOD
GO

-- CREATE A TEMP TABLE WITH LOCATION INFORMATION BY PATIENT-MONTH
DROP TABLE IF EXISTS ##TMP_PATKEY_LOCATION;
WITH QUERY_SOURCE_DATA AS(
	SELECT --TOP 100
		CAST(ME910_MHDO_MEMBERID AS INT) AS PATKEY
		,CAST(ME004_YEAR AS SMALLINT) AS YEAR
		,CAST(ME005_MONTH AS TINYINT) AS MONTH
		,ME015_PATCITY AS PATCITY
		,ME016_PATST AS PATST
		,ME017_PATZIP AS PATZIP
		,ME955_COUNTY_FIPS AS COUNTY_FIPS
	FROM ##TMP_ME
),
-- COUNT UP UNIQUE LOCATION COMBINATIONS BY PATIENT-MONTH
AGGREGATED AS(
	SELECT PATKEY, YEAR, MONTH, PATCITY, PATST, PATZIP, COUNTY_FIPS, COUNT(*) AS N
	FROM QUERY_SOURCE_DATA
	GROUP BY PATKEY, YEAR, MONTH, PATCITY, PATST, PATZIP, COUNTY_FIPS
),
-- TAKE THE LOCATION COMBINATION WITH THE MOST VOTES
RANKED_LOCATIONS AS(
	SELECT PATKEY, YEAR, MONTH, PATCITY, PATST, PATZIP, COUNTY_FIPS, N,
		ROW_NUMBER() OVER(PARTITION BY PATKEY, YEAR, MONTH ORDER BY N DESC) AS ROWNUM
	FROM AGGREGATED
)
SELECT PATKEY, YEAR, MONTH, PATCITY, PATST, PATZIP, COUNTY_FIPS
INTO ##TMP_PATKEY_LOCATION
FROM RANKED_LOCATIONS
WHERE ROWNUM = 1;
GO

-- VALIDATE THAT WE HAVE ONE LOCATION RECORD PER PATIENT-MONTH
DECLARE @NUMBER FLOAT;
WITH T1 AS(
	SELECT PATKEY, YEAR, MONTH, COUNT(*) AS N_RECORDS
	FROM ##TMP_PATKEY_LOCATION
	GROUP BY PATKEY, YEAR, MONTH
)
,T2 AS(
	SELECT
		N_RECORDS,
		COUNT(*) AS N_PATKEYS,
		COUNT(*) * 100.0 / SUM(COUNT(*)) OVER() AS PCT_PATKEYS
	FROM T1
	GROUP BY N_RECORDS
)
SELECT @NUMBER = PCT_PATKEYS FROM T2 WHERE N_RECORDS = 1;
IF @NUMBER != 100 THROW 50000, 'UNIQUE PATIENT LOCATION VAIDATION FAILED', 1;
GO


-- INSERT LOCATION INFORMATION INTO STG.ME
UPDATE STG.ME
SET
	STG.ME.PATCITY = T1.PATCITY,
	STG.ME.PATST = T1.PATST,
	STG.ME.PATZIP = T1.PATZIP,
	STG.ME.COUNTY_FIPS = T1.COUNTY_FIPS
FROM STG.ME
INNER JOIN (SELECT * FROM ##TMP_PATKEY_LOCATION) T1
ON STG.ME.PATKEY = T1.PATKEY AND STG.ME.YEAR = T1.YEAR AND STG.ME.MONTH = T1.MONTH;
GO


-- ADD MEDICAL ELIGIBILITY FLAGS TO STG.ME
WITH T1 AS(
	SELECT 
		ME019_RX 
		,PAYER_TYPE
		,ME910_MHDO_MEMBERID AS PATKEY
		,ME004_YEAR AS YEAR
		,ME005_MONTH AS MONTH
		,CASE WHEN ME019_RX = 'Y' THEN 1 ELSE 0 END AS RX_FLAG
		,CASE WHEN UPPER(TRIM(PAYER_TYPE)) = 'COMMERCIAL' THEN 1 ELSE 0 END AS COMMERCIAL_FLAG
		,CASE WHEN UPPER(TRIM(PAYER_TYPE)) = 'MEDICARE' THEN 1 ELSE 0 END AS MEDICARE_FLAG
		,CASE WHEN UPPER(TRIM(PAYER_TYPE)) = 'MEDICAID' THEN 1 ELSE 0 END AS MEDICAID_FLAG
	FROM ##TMP_ME
)
,T2 AS(
SELECT 
	PATKEY
	,YEAR
	,MONTH
	,CAST(MAX(RX_FLAG) AS BIT) AS RX_FLAG
	,CAST(MAX(COMMERCIAL_FLAG) AS BIT) AS COMMERCIAL_FLAG
	,CAST(MAX(MEDICARE_FLAG) AS BIT) AS MEDICARE_FLAG
	,CAST(MAX(MEDICAID_FLAG) AS BIT) AS MEDICAID_FLAG 
FROM T1
GROUP BY PATKEY, YEAR, MONTH
)
UPDATE STG.ME
SET 
	STG.ME.RX_FLAG = T2.RX_FLAG
	,STG.ME.COMMERCIAL_FLAG = T2.COMMERCIAL_FLAG
	,STG.ME.MEDICARE_FLAG = T2.MEDICARE_FLAG
	,STG.ME.MEDICAID_FLAG = T2.MEDICAID_FLAG
FROM STG.ME 
INNER JOIN T2
ON STG.ME.PATKEY = T2.PATKEY AND STG.ME.YEAR = T2.YEAR AND STG.ME.MONTH = T2.MONTH
GO

-- ADD PHARMACY ELIGIBILITY FLAG TO STG.ME
-- JUST ADD A FLAG TO THE ME TABLE IF THERE IS AT LEAST ONE MATCHING PE RECORD
WITH PHARMACY_ELIG AS(
	SELECT DISTINCT --TOP 10
		CAST(PE910_MHDO_MEMBERID AS INT) AS PATKEY,
		CAST(PE004_YEAR AS SMALLINT) AS YEAR,
		CAST(PE005_MONTH AS TINYINT) AS MONTH,
		CAST(1 AS BIT) AS PHARMACY_FLAG
	FROM RAW.PE
),
-- CREATE ONE PHARMACY_ELIG ROW PER STG.ME TABLE ROW FILLING IN ZEROS
PHARMACY_ELIG_ALL AS(
	SELECT
		ME.PATKEY,
		ME.YEAR,
		ME.MONTH,
		CASE WHEN PE.PHARMACY_FLAG IS NULL THEN CAST(0 AS BIT)
			ELSE PE.PHARMACY_FLAG
		END AS PHARMACY_FLAG
	-- FROM (SELECT TOP 10 * FROM STG.ME) ME -- FOR TESTING
	FROM (SELECT * FROM STG.ME) ME
	LEFT JOIN  PHARMACY_ELIG PE
	ON ME.PATKEY = PE.PATKEY AND ME.YEAR = PE.YEAR AND ME.MONTH = PE.MONTH
)
--SELECT * FROM PHARMACY_ELIG_ALL
UPDATE STG.ME
SET
	STG.ME.PHARMACY_FLAG = PEA.PHARMACY_FLAG
FROM STG.ME
LEFT JOIN PHARMACY_ELIG_ALL PEA
ON STG.ME.PATKEY = PEA.PATKEY AND STG.ME.YEAR = PEA.YEAR AND STG.ME.MONTH = PEA.MONTH;
GO

-- VALIDATE THAT AT LEAST 50% OF PATIENT-MONTHS HAVE MATCHING PHARMACY ELIGIBILITY
DECLARE @PCT_PHARM_ELIG AS FLOAT;
WITH T1 AS(
	SELECT PHARMACY_FLAG,
	COUNT(*) AS N,
	100.0*COUNT(*)/(SELECT COUNT(*) FROM STG.ME) AS PCT
FROM STG.ME
GROUP BY PHARMACY_FLAG
)
SELECT @PCT_PHARM_ELIG = PCT FROM T1 WHERE PHARMACY_FLAG = 1;
IF @PCT_PHARM_ELIG < 50 THROW 50000, 'LESS THAN 50% OF PATIENTS HAVE PHARMACY ELIGIBILITY!', 1;
-- LOOKS LIKE ABOUT 70% OF PATIENT-MONTHS HAVE BOTH MEDICAL AND PHARMACY ELIGIBILITY
GO

-- DROP TEMP TABLES
DROP TABLE IF EXISTS ##TMP_ME;
DROP TABLE IF EXISTS ##TMP_PATKEY_BIRTHYEAR;
DROP TABLE IF EXISTS ##TMP_PATKEY_LOCATION;
DROP TABLE IF EXISTS ##TMP_PATKEY_GENDER;
GO

/*
-- LOOK AT DISTRIBUTION OF ALL FLAGS
SELECT MEDICARE_FLAG, MEDICAID_FLAG, COMMERCIAL_FLAG, PHARMACY_FLAG,
	COUNT(*) AS N,
	1.0*COUNT(*)/(SELECT COUNT(*) FROM STG.ME) AS PCT
FROM STG.ME
GROUP BY MEDICARE_FLAG, MEDICAID_FLAG, COMMERCIAL_FLAG, PHARMACY_FLAG;
GO

IN ORDER...
-- ADD UNIQUE CONSTRAINTS
-- ADD COLUMNSTORE INDEX
-- ADD FOEIGN KEY REALTIONSHIPS
*/

