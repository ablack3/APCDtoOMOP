/*
-- VISIT DETAIL RECORDS ROLL UP INTO VISITS
-- EVERY VISIT DETAIL MUST ROLL UP INTO AT LEAST ONE VISIT OCCURRENCE

-- A VISIT DETAIL WILL BE SOMEWHAT SYNONYMOUS WITH A CLAIM LINE

-- A VISIT DETAIL IS A UNIQUE COMBINATION OF
-- FIRST DATE, LAST DATE, PROVIDER, CARE SITE, AND VISIT TYPE

-- WE NEED TO BE ABLE TO TIE PROCEDURES TO A VISIT DETAIL RECORD

-- WE NEED A VISIT DETAIL ID RECORD -  USE IDN
*/

-- CREATE PRVLNAME (free text provider field) TO NPI CROSSWALK
-- WHEN CARE SITE OR ORGANIZATION NPI ARE MISSING WE WILL IMPUTE THEM USING THIS CROSSWALK
-- SELECT TOP 10 * FROM STG.NPI;

DROP TABLE IF EXISTS ##PRVLNAME_NPI_CW;
WITH T1 AS(
    SELECT TRIM(UPPER(A.PRVLNAME)) AS PRVLNAME, B.ORGNAME, B.ORGNAME2,  B.NPI, COUNT(*) AS N
    -- SELECT B.NPI, TRIM(UPPER(A.C078_PRVLNAME)) AS PRVLNAME, B.ORGNAME, B.ORGNAME2, COUNT(*) AS N
    FROM STG.MC A
    -- FROM RAW.MC A
    INNER JOIN STG.NPI B
    ON A.NPI = B.NPI
    WHERE A.NPI IS NOT NULL
        AND B.ENTTYPE = 'ORGANIZATION'
        AND A.PRVLNAME IS NOT NULL
        -- PRVLANAME MUST CONTAIN AT LEAST TWO WORDS TO PREVENT INDIVIDUAL LAST NAMES FROM BEING INCLUDED
        AND LEN(A.PRVLNAME) - LEN(REPLACE(A.PRVLNAME, ' ','')) > 0
        -- PRVLNAME MUST BE AT LEAST 5 CHARACTERS
        AND LEN(A.PRVLNAME) > 5
        GROUP BY B.NPI, A.PRVLNAME, B.ORGNAME, B.ORGNAME2
    --ORDER BY A.PRVLNAME -- FOR CHECKING
),
T2 AS (
SELECT DISTINCT
    T1.PRVLNAME,
    --T1.NPI, -- FOR DEBUGGING
    FIRST_VALUE(NPI) OVER (PARTITION BY PRVLNAME ORDER BY N DESC) AS NPI
FROM T1
)
SELECT DISTINCT T2.PRVLNAME, T2.NPI AS PRVLNAME_NPI
     INTO ##PRVLNAME_NPI_CW
FROM T2;

-- SELECT TOP 100 * FROM ##PRVLNAME_NPI_CW;
GO


/*
-- CHECK THAT PRVLNAME IS UNIQUE
SELECT N, COUNT(*) AS NN
FROM (
    SELECT COUNT(*) AS N FROM STG.PRVLNAME_NPI_CW
    GROUP BY PRVLNAME
) A
GROUP BY N
*/

-- CREATE VISIT DETAIL SOURCE TO STANDARD MAP
DROP TABLE IF EXISTS ##VISIT_MAP;
SELECT --TOP 1000
    C1.CONCEPT_CODE AS SOURCE_CONCEPT_CODE
    ,C1.CONCEPT_ID AS SOURCE_CONCEPT_ID
    ,C1.CONCEPT_NAME AS SOURCE_CONCEPT_NAME
    ,C1.VOCABULARY_ID AS SOURCE_VOCABULARY_ID
    --,CR.CONCEPT_ID_2
    --,C2.*
    ,C2.CONCEPT_ID AS TARGET_CONCEPT_ID
    ,C2.CONCEPT_NAME AS TARGET_CONCEPT_NAME
INTO ##VISIT_MAP
FROM CDM.CONCEPT C1
LEFT JOIN CDM.CONCEPT_RELATIONSHIP CR
ON C1.CONCEPT_ID = CR.CONCEPT_ID_1
LEFT JOIN CDM.CONCEPT C2
ON CR.CONCEPT_ID_2 = C2.CONCEPT_ID
WHERE C1.VOCABULARY_ID IN('CMS Place of Service', 'UB04 Typ bill', 'UB04 Point of Origin', 'UB04 Pt dis status')
AND (CR.RELATIONSHIP_ID = 'Maps to' OR CR.RELATIONSHIP_ID IS NULL)

-- SOULD WE ADD LOGIC TO CHECK FOR VALID DATES?
-- SELECT TOP 100 * FROM ##VISIT_MAP
GO



-- CREATE THE TRM.VISIT_DETAIL_TABLE
-- BATCHES OF RECORDS WILL BE INSERTED INTO THIS TABLE
DROP TABLE IF EXISTS TRM.VISIT_DETAIL;
CREATE TABLE TRM.VISIT_DETAIL (
    VISIT_DETAIL_ID BIGINT NOT NULL
    ,VISIT_OCCURRENCE_ID BIGINT NOT NULL
    ,PERSON_ID BIGINT NOT NULL
    ,MHDO_CLAIM BIGINT NOT NULL
    ,VISIT_DETAIL_SOURCE_VALUE VARCHAR(20) NULL
    ,VISIT_DETAIL_SOURCE_VOCABULARY VARCHAR(20) NULL
    ,VISIT_DETAIL_TYPE_CONCEPT_ID INTEGER NULL
    ,FDATE DATETIME NULL
    ,LDATE DATETIME NULL
    ,NPI BIGINT NULL
    ,PRVLNAME VARCHAR(120) NULL
    ,SERVICING_NPI BIGINT NULL
    ,PRVLNAME_NPI BIGINT NULL
    ,ADMITTED_FROM_SOURCE_VALUE VARCHAR(10) NULL
    ,DISCHARGE_TO_SOURCE_VALUE VARCHAR(10) NULL
    ,ATT_NPI BIGINT NULL
    ,OP_NPI BIGINT NULL
    ,ALLOWED_AMT MONEY NULL
    ,VISIT_DETAIL_SOURCE_CONCEPT_ID INT NULL
    ,VISIT_DETAIL_SOURCE_CONCEPT_NAME VARCHAR(255) NULL
    ,VISIT_DETAIL_CONCEPT_ID INT NULL
    ,VISIT_DETAIL_CONCEPT_NAME VARCHAR(255) NULL
    ,ADMITTED_FROM_SOURCE_CONCEPT_ID INT NULL
    ,ADMITTED_FROM_SOURCE_CONCEPT_NAME VARCHAR(255)
    ,ADMITTED_FROM_CONCEPT_ID INT NULL
    ,ADMITTED_FROM_CONCEPT_NAME VARCHAR(255) NULL
    ,DISCHARGE_TO_SOURCE_CONCEPT_ID INT NULL
    ,DISCHARGE_TO_SOURCE_CONCEPT_NAME VARCHAR(255) NULL
    ,DISCHARGE_TO_CONCEPT_ID INT NULL
    ,DISCHARGE_TO_CONCEPT_NAME VARCHAR(255) NULL
    ,CARE_SITE_ID BIGINT NULL
    ,PROVIDER_ID BIGINT NULL
    ,ORGANIZATION_ID BIGINT NULL
)
GO


-- PROCESS MEDICAL CLAIMS IN BATCH - 10% OF PATIENTS AT A TIME
-- LAST ITERATION WILL MAP JUST 1 PATIENT
-- NEED 11 ITERATIONS THROUGH THE LOOP
-- SELECT * FROM STG.PATKEY_LIST;

DECLARE @ITERATION FLOAT
SET @ITERATION = 0;
WHILE @ITERATION <= 1
BEGIN
    PRINT @ITERATION;

    DROP TABLE IF EXISTS ##PATKEY_LIST;
    SELECT PATKEY_CHR AS PATKEY
    INTO ##PATKEY_LIST
    FROM (
        SELECT PATKEY_CHR, PERCENT_RANK() OVER(ORDER BY PATKEY_CHR)  AS PCT
        FROM STG.PATKEY_LIST
    ) A
    WHERE PCT >= @ITERATION AND PCT < @ITERATION + 0.1

    -- SELECT COUNT(*) FROM ##PATKEY_LIST;

    -- PUT MC DATA FOR BATCH IN A TEMP TABLE
    DROP TABLE IF EXISTS ##MC_BATCH;
    SELECT A.*
    INTO ##MC_BATCH
    FROM STG.MC A
    INNER JOIN ##PATKEY_LIST B
    ON A.PATKEY = B.PATKEY;

    -- SELECT COUNT(*) FROM ##PATKEY_LIST;
    -- SELECT TOP 100 * FROM ##MC_BATCH;


-- CREATE VISIT TYPE TABLE WITH THE SOURCE TO STANDARD CONCEPT MAPPINGS
DROP TABLE IF EXISTS ##TMP_VISIT_DETAIL;
WITH T0 AS(
    SELECT A.*, B.PRVLNAME_NPI
    FROM ##MC_BATCH A
    LEFT JOIN ##PRVLNAME_NPI_CW B
    ON A.PRVLNAME = B.PRVLNAME
)
,T1 AS(
    SELECT
        IDN AS VISIT_DETAIL_ID
        ,PATKEY AS PERSON_ID
        ,MHDO_CLAIM
        ,COALESCE(FACTYPE, BILLTYPE) AS VISIT_DETAIL_SOURCE_VALUE
        ,CASE WHEN FACTYPE IS NOT NULL THEN 'CMS Place of Service'
            WHEN BILLTYPE IS NOT NULL THEN 'UB04 Typ bill'
        END AS VISIT_DETAIL_SOURCE_VOCABULARY
        ,CASE
            WHEN FACTYPE IS NOT NULL THEN 32024 -- 32024 = Visit derived from encounter on medical professional claim
            WHEN BILLTYPE IS NOT NULL THEN 32023 -- 32023 = Visit derived from encounter on medical facility claim
        END AS VISIT_DETAIL_TYPE_CONCEPT_ID
        ,CAST(COALESCE(ADMDAT, FDATE) AS DATETIME) AS FDATE
        ,CAST(COALESCE(DISDAT, LDATE) AS DATETIME) AS LDATE
        ,TRY_CAST(TRIM(NPI) AS BIGINT) AS NPI
        ,PRVLNAME
        ,TRY_CAST(TRIM(SERVICING_NPI) AS BIGINT) AS SERVICING_NPI
        ,TRY_CAST(TRIM(PRVLNAME_NPI) AS BIGINT) AS PRVLNAME_NPI
        --,MC020_ADMTYPE AS ADMTYPE -- I DONT THINK WE CAN USE THIS FIELD
        ,ADMSR AS ADMITTED_FROM_SOURCE_VALUE
        ,PTDIS AS DISCHARGE_TO_SOURCE_VALUE
        ,TRY_CAST(TRIM(ATT_NPI) AS BIGINT) AS ATT_NPI
        ,TRY_CAST(TRIM(OP_NPI) AS BIGINT) AS OP_NPI
        ,TPAY + PREPAID + COINS + COPAY + DED AS ALLOWED_AMT -- POSSIBLY USE THIS FOR PRIORITIZING PROVIDERS
    FROM T0
    WHERE PATKEY IS NOT NULL AND
        IDN IS NOT NULL AND
        MHDO_CLAIM IS NOT NULL AND
        COALESCE(FACTYPE, BILLTYPE) IS NOT NULL
)
,T2 AS(
    SELECT T1.*
        ,M.SOURCE_CONCEPT_ID   AS VISIT_DETAIL_SOURCE_CONCEPT_ID
        ,M.SOURCE_CONCEPT_NAME AS VISIT_DETAIL_SOURCE_CONCEPT_NAME
        ,M.TARGET_CONCEPT_ID   AS VISIT_DETAIL_CONCEPT_ID
        ,M.TARGET_CONCEPT_NAME AS VISIT_DETAIL_CONCEPT_NAME
    FROM T1
    LEFT JOIN ##VISIT_MAP M
    ON T1.VISIT_DETAIL_SOURCE_VALUE = M.SOURCE_CONCEPT_CODE
    AND T1.VISIT_DETAIL_SOURCE_VOCABULARY = M.SOURCE_VOCABULARY_ID
)
,T3 AS(
    SELECT T2.*
        ,M.SOURCE_CONCEPT_ID   AS ADMITTED_FROM_SOURCE_CONCEPT_ID
        ,M.SOURCE_CONCEPT_NAME AS ADMITTED_FROM_SOURCE_CONCEPT_NAME
        ,M.TARGET_CONCEPT_ID   AS ADMITTED_FROM_CONCEPT_ID
        ,M.TARGET_CONCEPT_NAME AS ADMITTED_FROM_CONCEPT_NAME
    FROM T2
    LEFT JOIN (SELECT * FROM ##VISIT_MAP WHERE SOURCE_VOCABULARY_ID = 'UB04 Point of Origin') M
    ON T2.ADMITTED_FROM_SOURCE_VALUE = M.SOURCE_CONCEPT_CODE
)
,T4 AS(
    SELECT T3.*
        ,M.SOURCE_CONCEPT_ID   AS DISCHARGE_TO_SOURCE_CONCEPT_ID
        ,M.SOURCE_CONCEPT_NAME AS DISCHARGE_TO_SOURCE_CONCEPT_NAME
        ,M.TARGET_CONCEPT_ID   AS DISCHARGE_TO_CONCEPT_ID
        ,M.TARGET_CONCEPT_NAME AS DISCHARGE_TO_CONCEPT_NAME
    FROM T3
    LEFT JOIN (SELECT * FROM ##VISIT_MAP WHERE SOURCE_VOCABULARY_ID = 'UB04 Pt dis status') M
    ON T3.DISCHARGE_TO_SOURCE_VALUE = M.SOURCE_CONCEPT_CODE
)
SELECT * INTO ##TMP_VISIT_DETAIL FROM T4;
-- CHECK RESULT
-- SELECT COUNT(*) FROM ##TMP_VISIT_DETAIL;
-- SELECT TOP 100 * FROM ##TMP_VISIT_DETAIL;


-- ADD PROVIDER FIELDS TO THE TEMP VISIT DETAIL TABLE
ALTER TABLE ##TMP_VISIT_DETAIL ADD
    CARE_SITE_ID BIGINT,
    PROVIDER_ID BIGINT,
    ORGANIZATION_ID BIGINT;


-- ASSIGN A CARE SITE, INDIVIDUAL PROVIDER, AND OTHER ORGANIZATION TO EACH VISIT DETAIL RECORD
-- THIS STEP REQUIRES THAT CDM.CARE_SITE AND CDM.PROVIDER AND CDM.OTHER_ORGANIZATION TABLES ARE POPULATED
-- SELECT TOP 100 * FROM ##TMP_VISIT_DETAIL;
WITH T1 AS(
    SELECT --TOP 1000
        VISIT_DETAIL_ID,
        -- CARE SITE
        CASE WHEN NPI IN(SELECT CARE_SITE_ID FROM CDM.CARE_SITE) THEN NPI ELSE NULL
        END AS BILLING_CARE_SITE_NPI,
        CASE WHEN SERVICING_NPI IN(SELECT CARE_SITE_ID FROM CDM.CARE_SITE) THEN SERVICING_NPI ELSE NULL
        END AS SERVICING_CARE_SITE_NPI,
        CASE WHEN PRVLNAME_NPI IN(SELECT CARE_SITE_ID FROM CDM.CARE_SITE) THEN PRVLNAME_NPI ELSE NULL
        END AS PRVLNAME_CARE_SITE_NPI,
        -- PROVIDER
        CASE WHEN NPI IN(SELECT PROVIDER_ID FROM CDM.PROVIDER) THEN NPI ELSE NULL
        END AS BILLING_PROVIDER_NPI,
        CASE WHEN SERVICING_NPI IN(SELECT PROVIDER_ID FROM CDM.PROVIDER) THEN SERVICING_NPI ELSE NULL
        END AS SERVICING_PROVIDER_NPI,
        CASE WHEN ATT_NPI IN(SELECT PROVIDER_ID FROM CDM.PROVIDER) THEN ATT_NPI ELSE NULL
        END AS ATTENDING_PROVIDER_NPI,
        CASE WHEN OP_NPI IN(SELECT PROVIDER_ID FROM CDM.PROVIDER) THEN OP_NPI ELSE NULL
        END AS OPERATING_PROVIDER_NPI,
        -- OTHER ORGANIZATION NPI
        CASE WHEN NPI IN(SELECT ORGANIZATION_ID FROM CDM.OTHER_ORGANIZATION) THEN NPI ELSE NULL
        END AS BILLING_ORGANIZATION_NPI,
        CASE WHEN SERVICING_NPI IN(SELECT ORGANIZATION_ID FROM CDM.OTHER_ORGANIZATION) THEN SERVICING_NPI ELSE NULL
        END AS SERVICING_ORGANIZATION_NPI,
        CASE WHEN PRVLNAME_NPI IN(SELECT ORGANIZATION_ID FROM CDM.OTHER_ORGANIZATION) THEN PRVLNAME_NPI ELSE NULL
        END AS PRVLNAME_ORGANIZATION_NPI
    FROM ##TMP_VISIT_DETAIL
)
,T2 AS(
    SELECT VISIT_DETAIL_ID,
        -- SELECT ONE CARE SITE
        COALESCE(
            BILLING_CARE_SITE_NPI,
            SERVICING_CARE_SITE_NPI,
            PRVLNAME_CARE_SITE_NPI
        ) AS CARE_SITE_ID,
        -- SELECT ONE PROVIDER
        COALESCE(
            OPERATING_PROVIDER_NPI,
            ATTENDING_PROVIDER_NPI,
            SERVICING_PROVIDER_NPI,
            BILLING_PROVIDER_NPI
        ) AS PROVIDER_ID,
        -- SELECT ONE OTHER 0RGANIZATION
        COALESCE(
            BILLING_ORGANIZATION_NPI,
            SERVICING_ORGANIZATION_NPI,
            PRVLNAME_ORGANIZATION_NPI
        ) AS ORGANIZATION_ID
    FROM T1
)
UPDATE ##TMP_VISIT_DETAIL
SET CARE_SITE_ID = T2.CARE_SITE_ID,
    PROVIDER_ID = T2.PROVIDER_ID,
    ORGANIZATION_ID = T2.ORGANIZATION_ID,
    -- FILL IN MISSING LAST DATE WITH FIRST DATE
    LDATE = COALESCE(V.LDATE, V.FDATE)
FROM ##TMP_VISIT_DETAIL V
LEFT JOIN T2
ON V.VISIT_DETAIL_ID = T2.VISIT_DETAIL_ID;
-- THIS STEP IS VERY SLOW


-- SELECT TOP 10 * FROM ##TMP_VISIT_DETAIL

-- ADD VISIT OCCURRENCE ID TO TEMP VISIT DETAIL TABLE
ALTER TABLE ##TMP_VISIT_DETAIL ADD VISIT_OCCURRENCE_ID BIGINT;


-- ASSIGN VISIT_OCCURRENCE_ID (ROLL UP VISIT DETAIL RECORDS INTO VISITS)

-- CREATE THE KEY
--      KEY IS COMPOSED OF PATIENT, CLAIM NUMBER AND VISIT TYPE
-- ROWS WITH DIFFERENT PATIENT IDS CANNOT BE COMBINED INTO A SINGLE VISIT
-- ROWS WIIH DIFFERENT VISIT TYPES CANNOT BE COMBINED INTO A SINGLE VISIT
-- ROWS WITH THE SAME CLAIM NUMBER MUST HAVE THE SAME VISIT ID

-- THIS LOGIC IS VERY DIFFICULT TO COME UP WITH
-- WE WANT TO COLLAPSE FACILITY AND PROFESSIONAL COMPONENETS OF A HOSPITAL VISIT
-- HOWEVER WE WANT TO KEEP MULTIPLE HOSPITAL VISITS ON THE SAME DAY (TRANSFERS) SEPARATE
-- WE WANT TO COLLAPSE MULTIPLE CLAIMS FOR THE SAME PROCEDURE
-- BUT WE WANT TO KEEP OFFICE VISITS AT DIFFERENT LOCATIONS SEPARATE
-- THE APPROACH IMPLEMENTED HERE IS VERY IMPERFECT BUT IS AT LEAST A START

-- SELECT TOP 10 * FROM ##TMP_VISIT_DETAIL;

WITH T0 AS(
    -- CREATE THE KEY AND SET THE MAX ALLOWED GAP BETWEEN VISIT DETAIL RECORDS
    SELECT
        VISIT_DETAIL_ID,
        PERSON_ID,
        MHDO_CLAIM,
        -- VISIT_DETAIL_CONCEPT_NAME,
        -- CONCAT(PERSON_ID, '-', VISIT_DETAIL_CONCEPT_NAME) AS KEY_,
        -- CONCAT(PERSON_ID, '-',
        --     VISIT_DETAIL_CONCEPT_ID, '-',
        --     COALESCE(CARE_SITE_ID, PROVIDER_ID, ORGANIZATION_ID, 0)
        --  ) AS KEY_,
        COALESCE(VISIT_DETAIL_CONCEPT_ID, CARE_SITE_ID, PROVIDER_ID, ORGANIZATION_ID, 0) AS KEY_,
        FDATE,
        LDATE,
        -- MAX_ALLOWED_GAP CONTROLS THE MAX NUMBER OF DAYS BETWEEN VISITS ALLOWED FOR TWO POSSIBLE VISITS TO BE CONSIDERED THE SAME VISIT
        -- WE COULD USE DIFFERENT GAP LOGIC BASED ON VISIT TYPE
        -- A MAX GAP OF 0 MEANS THAT VISIT DETAIL RECORDS THAT HAVE THE SAME KEY AND END ONE DAY AND START THE NEXT WILL NOT BE COLLPASED (ONLY OVERLAPPING DATES WILL BE COLLAPSED)
        MAX_ALLOWED_GAP = 0
    FROM ##TMP_VISIT_DETAIL
    WHERE (LDATE IS NOT NULL) AND (FDATE IS NOT NULL) AND (LDATE >= FDATE)
)
,T1 AS(
    -- MAKE SURE THAT PERSON_ID, KEY, FDATE, AND LDATE HAVE THE SAME VALUE FOR ALL RECORDS ON A SINGLE CLAIM
    -- I.E. ENSURE THAT A CLAIM CANNOT BE SPLIT INTO MULTIPLE VISITS
    -- WHILE IN REALITY THERE ARE CASES WHERE A SINGLE CLAIM CAN HAVE MULTIPLE VISITS IMPLEMENTING THAT LOGIC MAKES THE ETL TOO COMPLICATED
    SELECT
        VISIT_DETAIL_ID,
        MAX(PERSON_ID) OVER(PARTITION BY MHDO_CLAIM) AS PERSON_ID,
        MHDO_CLAIM,
        MAX(KEY_) OVER(PARTITION BY MHDO_CLAIM) AS KEY_,
        MIN(FDATE) OVER(PARTITION BY MHDO_CLAIM) AS FDATE,
        MAX(LDATE) OVER(PARTITION BY MHDO_CLAIM) AS LDATE,
        MAX_ALLOWED_GAP
    FROM T0
)
,T2 AS(
    SELECT *
        --,LAG(LDATE, 1, NULL) OVER (PARTITION BY PERSON_ID, KEY_ ORDER BY FDATE, LDATE DESC) AS LAG_LDATE
        -- CUMULATIVE MAX END DATE WITHIN KEY
        ,MAX(LDATE) OVER (PARTITION BY PERSON_ID, KEY_ ORDER BY FDATE, LDATE DESC ROWS UNBOUNDED PRECEDING) AS MAX_LDATE
    FROM T1
)
,T3 AS(
     SELECT *
        -- ADD PREVIOUS MAX END DATE
        ,LAG(MAX_LDATE, 1, NULL) OVER (PARTITION BY PERSON_ID, KEY_ ORDER BY FDATE, LDATE DESC) AS LAG_MAX_LDATE
    FROM T2
)
,T4 AS(
    SELECT *
        -- CALCULATE THE DIFFERENCE BETWEEN FDATE AND POTENTIAL END OF PREVIOUS VISIT
        ,DATEDIFF(DY, LAG_MAX_LDATE, FDATE) AS DATE_GAP
    FROM T3
)
,T5 AS(
    -- FLAG A NEW VISIT
    SELECT *,
        CASE
            WHEN ((LAG_MAX_LDATE IS NULL) OR (DATE_GAP > MAX_ALLOWED_GAP)) THEN 1
            ELSE 0
        END AS NEW_VISIT_FLAG
    FROM T4
)
,T6 AS(
    -- CREATE VISIT_ID BY TAKING THE CUMULATIVE SUM OF THE NEW VISIT FLAGS
    SELECT *,
        -- NOT SURE IF I CAN LEAVE OFF KEY HERE... (IE DOES CHANGING THE PARTITION SCREW UP VISIT ID CREATION?)
        -- SUM(NEW_VISIT_FLAG) OVER (PARTITION BY PERSON_ID, KEY_ ORDER BY FDATE, LDATE DESC ROWS UNBOUNDED PRECEDING) AS VISIT_COUNT
        SUM(NEW_VISIT_FLAG) OVER (PARTITION BY PERSON_ID ORDER BY FDATE, LDATE DESC ROWS UNBOUNDED PRECEDING) AS VISIT_COUNT
    FROM T5
)
,T7 AS(
    SELECT *,
        -- ASSUME THAT NO PERSON HAS MORE THAN 9,999 VISITS
        10000*PERSON_ID + VISIT_COUNT AS VISIT_OCCURRENCE_ID
    FROM T6
)
UPDATE ##TMP_VISIT_DETAIL
SET VISIT_OCCURRENCE_ID = T7.VISIT_OCCURRENCE_ID
FROM ##TMP_VISIT_DETAIL V
LEFT JOIN T7
ON V.VISIT_DETAIL_ID = T7.VISIT_DETAIL_ID;

-- SELECT TOP 10 * FROM ##TMP_VISIT_DETAIL;

-- PUT BATCH INTO TRM.VISIT_DETAIL
INSERT INTO TRM.VISIT_DETAIL
SELECT DISTINCT
    VISIT_DETAIL_ID
    ,VISIT_OCCURRENCE_ID
    ,PERSON_ID
    ,MHDO_CLAIM
    ,VISIT_DETAIL_SOURCE_VALUE
    ,VISIT_DETAIL_SOURCE_VOCABULARY
    ,VISIT_DETAIL_TYPE_CONCEPT_ID
    ,FDATE
    ,LDATE
    ,NPI
    ,PRVLNAME
    ,SERVICING_NPI
    ,PRVLNAME_NPI
    ,ADMITTED_FROM_SOURCE_VALUE
    ,DISCHARGE_TO_SOURCE_VALUE
    ,ATT_NPI
    ,OP_NPI
    ,ALLOWED_AMT
    ,VISIT_DETAIL_SOURCE_CONCEPT_ID
    ,VISIT_DETAIL_SOURCE_CONCEPT_NAME
    ,VISIT_DETAIL_CONCEPT_ID
    ,VISIT_DETAIL_CONCEPT_NAME
    ,ADMITTED_FROM_SOURCE_CONCEPT_ID
    ,ADMITTED_FROM_SOURCE_CONCEPT_NAME
    ,ADMITTED_FROM_CONCEPT_ID
    ,ADMITTED_FROM_CONCEPT_NAME
    ,DISCHARGE_TO_SOURCE_CONCEPT_ID
    ,DISCHARGE_TO_SOURCE_CONCEPT_NAME
    ,DISCHARGE_TO_CONCEPT_ID
    ,DISCHARGE_TO_CONCEPT_NAME
    ,CARE_SITE_ID
    ,PROVIDER_ID
    ,ORGANIZATION_ID
FROM ##TMP_VISIT_DETAIL
WHERE
    VISIT_OCCURRENCE_ID IS NOT NULL AND
    VISIT_DETAIL_ID IS NOT NULL AND
    PERSON_ID IS NOT NULL AND
    MHDO_CLAIM IS NOT NULL
;


-- INCREMENT LOOP COUNTER
SET @ITERATION = @ITERATION + 0.1;

END;

GO


-- DROP TEMP TABLES
DROP TABLE IF EXISTS ##TMP_VISIT_DETAIL;
DROP TABLE IF EXISTS ##VISIT_MAP;
DROP TABLE IF EXISTS ##PATKEY_LIST;
DROP TABLE IF EXISTS ##MC_BATCH;
DROP TABLE IF EXISTS ##PRVLNAME_NPI_CW;
GO



/*
-- THE CONTRACT THAT THIS SCRIPT ADHERES TO IS THAT ALL OF THE DATA NEEDED TO POPULATE
-- THE CDM.VISIT_DETAIL TABLE MUST BE IN THE STG.VISIT_DETAL TABLE

-- CHECK ROW COUNTS BETWEEN SOURCE AND TARGET
-- WE WOULD EXPECT TO DROP SOME ROWS
-- SELECT COUNT(*) FROM STG.MC
-- SELECT COUNT(*) FROM TRM.VISIT_DETAIL

-- SELECT TOP 100  * FROM TRM.VISIT_DETAIL
-- ORDER BY PERSON_ID, FDATE, LDATE DESC;

-- SELECT TOP 100  * FROM TRM.VISIT_DETAIL
-- ORDER BY PERSON_ID, FDATE, LDATE DESC;
*/






