/*
THIS SCRIPT CREATES THE TRM.DX_MAP TABLE WHICH IS A
CROSSWALK BETWEEN ICD CODES AND THIER STANDARD CONCEPTS

IT CREATES TRM.CONDITION_OCCURRENCE, TRM.OBSERVATION, TRM.MEASUREMENT, AND TRM.PROCEDURE_OCCURRENCE
IT POPULATES EACH OF THESE FOUR STAGE EVENT TABLES WITH DATA FROM THE STG.DX TABLE (ICD CODES)

Do we need batch processing for this step?
*/

-- CREATE STG.DX_MAP CROSSWALK TABLE
DROP TABLE IF EXISTS  ##DX_MAP;
-- Get ICD codes
WITH T1 AS(
SELECT --TOP 10
    VOCABULARY_ID AS SOURCE_VOCABULARY_ID,
    REPLACE(CONCEPT_CODE, '.', '') AS SOURCE_CONCEPT_CODE,
    CONCEPT_ID AS SOURCE_CONCEPT_ID
FROM CDM.CONCEPT
WHERE VOCABULARY_ID IN ('ICD9CM', 'ICD10CM')
),
-- Get the standard condtion concepts
T2 AS(
    SELECT T1.*,
        RELATIONSHIP_ID,
        CR.CONCEPT_ID_2 AS TARGET_CONCEPT_ID
    FROM T1
    INNER JOIN CDM.CONCEPT_RELATIONSHIP CR
    ON T1.SOURCE_CONCEPT_ID = CR.CONCEPT_ID_1
    WHERE RELATIONSHIP_ID = 'Maps to' -- DO WE NEED TO INCLUDE 'MAPS TO VALUE'?
),
-- Get the concept info for the standard concepts
T3 AS(
SELECT *
FROM T2
INNER JOIN CDM.CONCEPT C
    ON T2.TARGET_CONCEPT_ID = C.CONCEPT_ID
),
SOURCE_DX AS(
    SELECT VOCABULARY, DX, COUNT(*) AS N_RECORDS
    FROM STG.DX
    GROUP BY VOCABULARY, DX
)
SELECT
    VOCABULARY,
    DX,
    N_RECORDS,
    COALESCE(CONCEPT_ID, 0) AS CONDITION_CONCEPT_ID,
    -- DEFAULT DOMAIN FOR DX CODES IS CONDITION DOMAIN
    COALESCE(DOMAIN_ID, 'Condition') AS DOMAIN_ID,
    DX AS CONDITION_SOURCE_VALUE,
    COALESCE(SOURCE_CONCEPT_ID, 0) AS CONDITION_SOURCE_CONCEPT_ID
INTO ##DX_MAP
FROM SOURCE_DX
LEFT JOIN T3
ON SOURCE_DX.VOCABULARY = T3.SOURCE_VOCABULARY_ID AND SOURCE_DX.DX = T3.SOURCE_CONCEPT_CODE;

GO

/*


SELECT TOP 10 * FROM STG.DX;

SELECT TOP 10 * FROM CDM.CONCEPT_RELATIONSHIP

-- CREATE A DX CODE SOURCE TO STANDARD CONCEPT MAPPING TABLE
SELECT TOP 10 * FROM CDM.CONCEPT
WHERE VOCABULARY_ID IN ('ICD9CM', 'ICD10CM');

-- Do some data checks
SELECT COUNT(*) FROM  STG.DX_MAP
SELECT TOP 100 * FROM  STG.DX_MAP
SELECT DISTINCT DOMAIN_ID FROM  STG.DX_MAP;
GO

-- check that there is one row per idn IN STG.MC
SELECT N, COUNT(*) AS NN FROM (
SELECT IDN, COUNT(*) AS N FROM STG.MC GROUP BY IDN
) ASDF
GROUP BY N;
-- WHY ARE SOME ROWS DUPLICATED. THEY SHOULD NOT BE.
*/



/*
-- which domains do Icd codes map to?
-- 85% go to condition_occurrence
-- 8% go to Observation,
-- 5% go to procedure
-- 0.5% go to measurement

WITH T1 AS (
    SELECT DOMAIN_ID, SUM(N_RECORDS) AS N_RECORDS FROM STG.DX_LOOKUP GROUP BY DOMAIN_ID
)
SELECT DOMAIN_ID, N_RECORDS, 1.0*N_RECORDS/SUM(N_RECORDS) OVER() AS PCT_RECORDS
FROM T1

-- HOW SHOULD WE HANDLE CHECKING THAT DATES FOR DX CODES ARE VALID?

SELECT TOP 10 * FROM ##DX_MAP;
-- GET THE SOURCE ICD DATA READY
-- SOURCE ICD DATA COULD GO TO CONDITION, PROCEDURE, MEASUREMENT OR OBSERVATION TABLES
SELECT TOP 10 * FROM STG.DX

SELECT TOP 10 * FROM STG.MC;
SELECT TOP 10 * FROM CDM.provider;

-- GET CLAIM LEVEL INFO: START DATE, END DATE, PROVIDER, VISIT

SELECT TOP 10 * FROM STG.VISIT_DETAIL;
*/




-- CREATE CLAIM HEADER LEVEL DATA WITH DATES, PROVIDER AND VISIT ID
DROP TABLE IF EXISTS ##CLAIM_LEVEL_DATA;
WITH T1 AS(
    -- ROLL UP TO CLAIM LEVEL
    SELECT DISTINCT
        MHDO_CLAIM,
        MIN(FDATE) OVER(PARTITION BY MHDO_CLAIM) AS MIN_FDATE,
        MAX(LDATE) OVER(PARTITION BY MHDO_CLAIM) AS MAX_LDATE,
        -- MAX(BILLTYPE) OVER(PARTITION BY MHDO_CLAIM) AS BILLTYPE,
        -- MAX(FACTYPE) OVER(PARTITION BY MHDO_CLAIM) AS FACTYPE,
        -- TAKE THE NPI WITH THE LARGEST TPAY AMT UNLESS IT IS NULL
        FIRST_VALUE(NPI) OVER(PARTITION BY MHDO_CLAIM ORDER BY IIF(NPI IS NULL, -1000000, TPAY) DESC) AS NPI,
        FIRST_VALUE(SERVICING_NPI) OVER(PARTITION BY MHDO_CLAIM ORDER BY IIF(SERVICING_NPI IS NULL, -1000000, TPAY) DESC) AS SERVICING_NPI,
        FIRST_VALUE(ATT_NPI) OVER(PARTITION BY MHDO_CLAIM ORDER BY IIF(ATT_NPI IS NULL, -1000000, TPAY) DESC) AS ATT_NPI
    FROM STG.MC
)
,T2 AS(
    --PULL OUT INDIVIDUAL PROVIDER
    SELECT
        MHDO_CLAIM,
        MIN_FDATE,
        MAX_LDATE,
        COALESCE(
            CASE WHEN ATT_NPI IN(SELECT NPI FROM CDM.PROVIDER) THEN ATT_NPI ELSE NULL END,
            CASE WHEN SERVICING_NPI IN(SELECT NPI FROM CDM.PROVIDER) THEN SERVICING_NPI ELSE NULL END,
            CASE WHEN NPI IN(SELECT NPI FROM CDM.PROVIDER) THEN NPI ELSE NULL END
        ) AS PROVIDER_ID
      FROM T1
)
,VISIT AS(
    -- GET CLAIM NUMBER TO VISIT CROSSWALK
    -- WE PROBABLY WANT A RULE THAT CLAIMS MUST ROLL UP INTO VISITS TO AVOID CONFUSION
    SELECT DISTINCT
        B.MHDO_CLAIM,
        A.VISIT_OCCURRENCE_ID,
        A.PROVIDER_ID
    FROM CDM.visit_occurrence A
    JOIN (SELECT DISTINCT MHDO_CLAIM, VISIT_OCCURRENCE_ID FROM TRM.VISIT_DETAIL) B
    ON A.VISIT_OCCURRENCE_ID = B.VISIT_OCCURRENCE_ID
)
SELECT
    T2.MHDO_CLAIM,
    T2.MIN_FDATE,
    T2.MAX_LDATE,
    -- USE PROVIDER ON VISIT IF WE DONT HAVE ONE ON CLAIM
    COALESCE(T2.PROVIDER_ID, VISIT.PROVIDER_ID) AS PROVIDER_ID,
    VISIT.VISIT_OCCURRENCE_ID
INTO ##CLAIM_LEVEL_DATA
FROM T2
JOIN  VISIT
ON T2.MHDO_CLAIM = VISIT.MHDO_CLAIM
-- ORDER BY MHDO_CLAIM
;
GO


/*
SELECT TOP 10 * FROM ##CLAIM_LEVEL_DATA;
SELECT TOP 10 * FROM STG.DX
SELECT TOP 10 * FROM ##DX_MAP
SELECT DISTINCT DOMAIN_ID FROM ##DX_MAP;
-- PROCEDURE, CONDITION, MEASUREMENT, OBSERVATION
STG.DX TABLE FEEDS FOUR EVENT TABLES IN THE CDM
*/



-- INSERT ICD/DX RECORDS INTO THE STG.CONDITION_OCCURRENCE TABLE
DELETE FROM TRM.CONDITION_OCCURRENCE WHERE SOURCE = 'STG.DX';
INSERT INTO TRM.CONDITION_OCCURRENCE
SELECT
    DX.PATKEY AS PERSON_ID,
    DX_MAP.CONDITION_CONCEPT_ID,
    CLM.MIN_FDATE AS CONDITION_START_DATE,
    TRY_CAST(CLM.MIN_FDATE AS DATETIME) AS CONDITION_START_DATETIME,
    CLM.MAX_LDATE AS CONDITION_END_DATE,
    TRY_CAST(CLM.MAX_LDATE AS DATETIME) AS CONDITION_END_DATETIME,
    CASE WHEN DX.PRIMARY_FLAG = 1 THEN 44786627 ELSE 0 END AS CONDITION_TYPE_CONCEPT_ID,
    0 AS CONDITION_STATUS_CONCEPT_ID,
    NULL AS STOP_REASON,
    CLM.PROVIDER_ID,
    CLM.VISIT_OCCURRENCE_ID,
    NULL AS VISIT_DETAIL_ID,
    DX_MAP.CONDITION_SOURCE_VALUE,
    DX_MAP.CONDITION_SOURCE_CONCEPT_ID,
    TRY_CAST(DX.PRIMARY_FLAG AS VARCHAR(5)) AS CONDITION_STATUS_SOURCE_VALUE,
    CAST('STG.DX' AS VARCHAR(20)) AS SOURCE
FROM STG.DX DX
INNER JOIN ##DX_MAP DX_MAP
ON DX.DX = DX_MAP.DX AND DX.VOCABULARY = DX_MAP.VOCABULARY
INNER JOIN ##CLAIM_LEVEL_DATA CLM
ON DX.MHDO_CLAIM = CLM.MHDO_CLAIM
WHERE DX_MAP.DOMAIN_ID = 'Condition'; -- OR DOMAIN_ID IS NULL?
GO



-- INSERT ICD/DX RECORDS INTO STG.PROCEDURE_OCCURRENCE
DELETE FROM TRM.PROCEDURE_OCCURRENCE WHERE SOURCE = 'STG.DX';
INSERT INTO TRM.PROCEDURE_OCCURRENCE
SELECT
    DX.PATKEY AS PERSON_ID,
    DX_MAP.CONDITION_CONCEPT_ID AS PROCEDURE_CONCEPT_ID,
    CLM.MIN_FDATE AS PROCEDURE_DATE,
    TRY_CAST(CLM.MIN_FDATE AS DATETIME) AS PROCEDURE_DATETIME,
    32468 AS PROCEDURE_TYPE_CONCEPT_ID, -- 32468 = INFERRED FROM CLAIM
    0 AS MODIFIER_CONCEPT_ID,
    NULL AS QUANTITY,
    CLM.PROVIDER_ID,
    CLM.VISIT_OCCURRENCE_ID,
    NULL AS VISIT_DETAIL_ID,
    DX_MAP.CONDITION_SOURCE_VALUE AS PROCEDURE_SOURCE_VALUE,
    DX_MAP.CONDITION_SOURCE_CONCEPT_ID AS PROCEDURE_SOURCE_CONCEPT_ID,
    NULL AS MODIFIER_SOURCE_VALUE,
    'STG.DX' AS SOURCE
FROM STG.DX DX
INNER JOIN ##DX_MAP DX_MAP
ON DX.DX = DX_MAP.DX AND DX.VOCABULARY = DX_MAP.VOCABULARY
INNER JOIN ##CLAIM_LEVEL_DATA CLM
ON DX.MHDO_CLAIM = CLM.MHDO_CLAIM
WHERE DX_MAP.DOMAIN_ID = 'Procedure';
GO



-- INSERT ICD/DX RECORDS INTO STG.OBSERVATION TABLE
DELETE FROM TRM.OBSERVATION WHERE SOURCE = 'STG.DX';
INSERT INTO TRM.OBSERVATION
SELECT
    DX.PATKEY AS PERSON_ID
    ,DX_MAP.CONDITION_CONCEPT_ID AS OBSERVATION_CONCEPT_ID
    ,CLM.MIN_FDATE AS OBSERVATION_DATE
    ,TRY_CAST(CLM.MIN_FDATE AS DATETIME) AS OBSERVATION_DATETIME
    ,CAST(32467 AS INTEGER) AS OBSERVATION_TYPE_CONCEPT_ID -- 32467 = INFERRED FROM CLAIM
    ,NULL AS VALUE_AS_NUMBER
    ,NULL AS VALUE_AS_STRING
    ,NULL AS VALUE_AS_CONCEPT_ID
    ,NULL AS QUALIFIER_CONCEPT_ID
    ,NULL AS UNIT_CONCEPT_ID
    ,CLM.PROVIDER_ID
    ,CLM.VISIT_OCCURRENCE_ID
    ,NULL AS VISIT_DETAIL_ID
    ,DX_MAP.CONDITION_SOURCE_VALUE AS OBSERVATION_SOURCE_VALUE
    ,DX_MAP.CONDITION_SOURCE_CONCEPT_ID AS OBSERVATION_SOURCE_CONCEPT_ID
    ,NULL AS UNIT_SOURCE_VALUE
    ,NULL AS QUALIFIER_SOURCE_VALUE
    ,NULL AS OBSERVATION_EVENT_ID
    ,0 AS OBS_EVENT_FIELD_CONCEPT_ID
    ,NULL AS VALUE_AS_DATETEIME
    ,'STG.DX' AS SOURCE
FROM STG.DX DX
INNER JOIN ##DX_MAP DX_MAP
ON DX.DX = DX_MAP.DX AND DX.VOCABULARY = DX_MAP.VOCABULARY
INNER JOIN ##CLAIM_LEVEL_DATA CLM
ON DX.MHDO_CLAIM = CLM.MHDO_CLAIM
WHERE DX_MAP.DOMAIN_ID = 'Observation';
GO



-- INSERT ICD/DX RECORDS INTO STG.MEASUREMENT
DELETE FROM TRM.MEASUREMENT WHERE SOURCE = 'STG.DX';
INSERT INTO TRM.MEASUREMENT
SELECT
    DX.PATKEY AS PERSON_ID,
    DX_MAP.CONDITION_CONCEPT_ID AS MEASUREMENT_CONCEPT_ID,
    CLM.MIN_FDATE AS MEASUREMENT_DATE,
    TRY_CAST(CLM.MIN_FDATE AS DATETIME) AS MEASUREMENT_DATETIME,
    NULL AS MEASUREMENT_TIME,
   CAST(32466 AS INTEGER) AS MEASUREMENT_TYPE_CONCEPT_ID, -- 32466 = INFERRED FROM CLAIM
    NULL AS OPERATOR_CONCEPT_ID,
    NULL AS VALUE_AS_NUMBER,
    NULL AS VALUE_AS_CONCEPT_ID, -- SHOULD WE LOOK AT 'MAPS TO VALUE' RELATIONSHIPS TO FILL THESE IN?
    NULL AS UNIT_CONCEPT_ID,
    NULL AS RANGE_LOW,
    NULL AS RANGE_HIGH,
    CLM.PROVIDER_ID,
    CLM.VISIT_OCCURRENCE_ID,
    NULL AS VISIT_DETAIL_ID,
    DX_MAP.CONDITION_SOURCE_VALUE AS MEASUREMENT_SOURCE_VALUE,
    DX_MAP.CONDITION_SOURCE_CONCEPT_ID AS MEASUREMENT_SOURCE_CONCEPT_ID,
    NULL AS UNIT_SOURCE_VALUE,
    NULL AS VALUE_SOURCE_VALUE,
    'STG.DX' AS SOURCE
FROM STG.DX DX
INNER JOIN ##DX_MAP DX_MAP
ON DX.DX = DX_MAP.DX AND DX.VOCABULARY = DX_MAP.VOCABULARY
INNER JOIN ##CLAIM_LEVEL_DATA CLM
ON DX.MHDO_CLAIM = CLM.MHDO_CLAIM
WHERE DX_MAP.DOMAIN_ID = 'Measurement';
GO


/*
-- CHECK RECORD COUNTS
SELECT COUNT(*) FROM STG.DX;
SELECT COUNT(*) FROM TRM.CONDITION_OCCURRENCE;
*/

